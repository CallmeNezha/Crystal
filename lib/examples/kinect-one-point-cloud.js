// Generated by CoffeeScript 1.12.2
(function() {
  var Kinect, THREE, View, env, fragmentShader, fs, vertexShader;

  fs = require('fs');

  env = require('../../env');

  THREE = require(env.PATH.THREE + "build/three");

  Kinect = require("./Crystal_Geo.node");

  console.log(Kinect);

  (function() {
    var file;
    file = fs.readFileSync(env.PATH.THREE + "examples/js/loaders/STLLoader.js", 'utf-8');
    eval(file);
    file = fs.readFileSync(env.PATH.THREE + "examples/js/loaders/3MFLoader.js", 'utf-8');
    eval(file);
    file = fs.readFileSync(env.PATH.THREE + "examples/js/loaders/OBJLoader.js", 'utf-8');
    eval(file);
    file = fs.readFileSync(env.PATH.THREE + "examples/js/controls/OrbitControls.js", 'utf-8');
    return eval(file);
  })();

  vertexShader = "  uniform float width;\n  uniform float height;\n  varying vec2 vUv;\n  uniform sampler2D map;\n  uniform float time;\n\nvoid main()\n{\n    vUv = vec2(position.x / width, position.y / height);\n    vec2 vUvsround[8];\n\n    vUvsround[0] = vec2(position.x - 1.0, position.y + 1.0);\n    vUvsround[1] = vec2(position.x - 1.0, position.y);\n    vUvsround[2] = vec2(position.x - 1.0, position.y - 1.0);\n    vUvsround[3] = vec2(position.x, position.y - 1.0);\n    vUvsround[4] = vec2(position.x + 1.01, position.y - 1.0);\n    vUvsround[5] = vec2(position.x + 1.0, position.y);\n    vUvsround[6] = vec2(position.x + 1.0, position.y + 1.0);\n    vUvsround[7] = vec2(position.x, position.y + 1.0);\n\n    vec4 center = texture2D(map, vUv);\n\n    float error = 0.0;\n    for(int i=0; i < 8; ++i) {\n      vUvsround[i] = vec2(vUvsround[i].x / width, vUvsround[i].y / height);\n      vec4 color = texture2D(map, vUvsround[i]);\n      error += abs(center.z - color.z);\n    }\n    if (error > 0.1) {\n      center.z = 0.0;\n    }\n    vec3 offset = vec3(0.0, 0.0, center.z * 600.0);\n    if (abs(offset.z) < 0.01) offset.z = 600.0;\n	vec4 mvPosition = modelViewMatrix * vec4( position + offset, 1.0 );\n    gl_PointSize = 5.0;\n	gl_Position = projectionMatrix * mvPosition;\n}";

  fragmentShader = "uniform sampler2D map;\nvarying vec2 vUv;\nuniform float time;\n\nvoid main() {\n\n  vec4 color = texture2D(map, vUv);\n  gl_FragColor = vec4(color.rgb, 1.0);\n}";

  View = (function() {
    function View() {
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 10000);
      this.clock = new THREE.Clock();
      this.objects = {};
      this._control = null;
    }

    View.prototype.init = function(renderer) {
      var geometry, height, material, mesh, vertices, width;
      renderer.setClearColor(0xDBDBDB);
      renderer.gammaInput = true;
      renderer.gammaOutput = true;
      this._control = new THREE.OrbitControls(this.camera, renderer.domElement);
      this._control.enableZoom = true;
      this.camera.position.set(20, 20, 0);
      this.camera.lookAt(new THREE.Vector3());
      this.scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 1));
      this._addShadowedLight(1, 1, 1);
      Kinect.CreateKinect();
      width = 512;
      height = 424;
      this._depthframe = new Float32Array(width * height);
      geometry = new THREE.BufferGeometry();
      vertices = new Float32Array(width * height * 3);
      
    for ( var i = 0, j = 0, l = vertices.length; i < l; i += 3, j ++ ) {
      vertices[ i ] = j % width;
      vertices[ i + 1 ] = Math.floor( j / width );
    }
    ;
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      this._texture = new THREE.Texture(this._generateTexture());
      this._texture.needsUpdate = true;
      this._uniforms = {
        map: {
          value: this._texture
        },
        width: {
          value: width
        },
        height: {
          value: height
        },
        time: {
          value: 0.0
        },
        blending: THREE.AdditiveBlending,
        depthTest: false,
        depthWrite: false,
        transparent: true
      };
      material = new THREE.ShaderMaterial({
        uniforms: this._uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
      });
      mesh = new THREE.Points(geometry, material);
      mesh.scale.set(0.01, 0.01, 0.01);
      this.scene.add(mesh);
    };

    View.prototype.onRender = function() {
      var dt, success;
      dt = this.clock.getDelta();
      this._control.update();
      success = Kinect.GetDepthBuffer(this._depthframe);
      this._putImageData();
      this._texture.needsUpdate = true;
      this._uniforms.time.value += 0.05;
    };

    View.prototype.onExit = function() {
      Kinect.DestroyKinect();
    };

    View.prototype._addShadowedLight = function(x, y, z, d, color, intensity) {
      var directLight;
      if (d == null) {
        d = 10000;
      }
      if (color == null) {
        color = 0xffffbb;
      }
      if (intensity == null) {
        intensity = 0.2;
      }
      directLight = new THREE.DirectionalLight(color, intensity);
      directLight.position.set(x, y, z);
      this.scene.add(directLight);
    };

    View.prototype._generateTexture = function() {
      var canvas, i, image, j, ref;
      canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 424;
      this._context = canvas.getContext('2d');
      image = this._context.getImageData(0, 0, 512, 424);
      for (i = j = 0, ref = 512 * 424; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        image.data[i] = Math.random() * 255;
      }
      this._context.putImageData(image, 0, 0);
      return canvas;
    };

    View.prototype._putImageData = function() {
      var image, intensity, ipxl, j, ref;
      image = this._context.getImageData(0, 0, 512, 424);
      for (ipxl = j = 0, ref = 512 * 424 * 4; j < ref; ipxl = j += 4) {
        intensity = this._depthframe[ipxl / 4];
        intensity = intensity < 1800 ? (intensity / 1800) * 255 : 0;
        image.data[ipxl] = intensity;
        image.data[ipxl + 1] = intensity;
        image.data[ipxl + 2] = intensity;
        image.data[ipxl + 3] = 255;
      }
      this._context.putImageData(image, 0, 0);
    };

    return View;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = View;
  }

}).call(this);

//# sourceMappingURL=kinect-one-point-cloud.js.map
