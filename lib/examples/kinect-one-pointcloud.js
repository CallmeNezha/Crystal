// Generated by CoffeeScript 1.12.2
(function() {
  var Kinect, THREE, View, env, fragmentShader, fs, vertexShader;

  fs = require('fs');

  env = require('../../env');

  THREE = require(env.PATH.THREE + "build/three");

  Kinect = require("./Crystal_Geo.node");

  console.log(Kinect);

  (function() {
    var file;
    file = fs.readFileSync(env.PATH.THREE + "examples/js/loaders/STLLoader.js", 'utf-8');
    eval(file);
    file = fs.readFileSync(env.PATH.THREE + "examples/js/loaders/3MFLoader.js", 'utf-8');
    eval(file);
    file = fs.readFileSync(env.PATH.THREE + "examples/js/loaders/OBJLoader.js", 'utf-8');
    eval(file);
    file = fs.readFileSync(env.PATH.THREE + "examples/js/controls/OrbitControls.js", 'utf-8');
    return eval(file);
  })();

  vertexShader = "  //uniform sampler2D map;\n\n  //uniform float width;\n  //uniform float height;\n  //uniform float nearClipping, farClipping;\n\n  uniform float pointSize;\n  //uniform float zOffset;\n\n  //varying vec2 vUv;\n\n  //const float XtoZ = 1.11146; // tan( 1.0144686 / 2.0 ) * 2.0;\n  //const float YtoZ = 0.83359; // tan( 0.7898090 / 2.0 ) * 2.0;\n\n  //void main() {\n\n    //vUv = vec2( position.x / width, position.y / height );\n    //vec4 color = texture2D( map, vUv );\n    //float depth = ( color.r + color.g + color.b ) / 3.0;\n\n\n    //Projection code by @kcmic\n\n    //float z = ( 1.0 - depth ) * (farClipping - nearClipping) + nearClipping;\n    //vec4 pos = vec4(\n      //( position.x / width - 0.5 ) * z * XtoZ,\n      //( position.y / height - 0.5 ) * z * YtoZ,\n      //- z + zOffset,\n      //1.0);\n    gl_PointSize = pointSize; gl_Position = projectionMatrix * modelViewMatrix * position;\n\n}\n";

  fragmentShader = "  uniform sampler2D map;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n}";

  View = (function() {
    function View() {
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 10000);
      this.clock = new THREE.Clock();
      this.objects = {};
      this._control = null;
    }

    View.prototype.init = function(renderer) {
      var farClipping, geometry, height, material, mesh, nearClipping, vertices, width;
      renderer.setClearColor(0xDBDBDB);
      renderer.gammaInput = true;
      renderer.gammaOutput = true;
      this._control = new THREE.OrbitControls(this.camera, renderer.domElement);
      this._control.enableZoom = true;
      this.camera.position.set(20, 20, 0);
      this.camera.lookAt(new THREE.Vector3());
      this.scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 1));
      Kinect.CreateKinect();
      this._depthframe = new Float32Array(512 * 424);
      geometry = new THREE.PlaneGeometry(1, 1);
      this._texture = new THREE.Texture(this._generateTexture());
      this._texture.needsUpdate = true;
      width = 512;
      height = 424;
      nearClipping = 850;
      farClipping = 4000;
      geometry = new THREE.BufferGeometry();
      vertices = new Float32Array(width * height * 3);
      
    for ( var i = 0, j = 0, l = vertices.length; i < l; i += 3, j ++ ) {
      vertices[ i ] = j % width;
      vertices[ i + 1 ] = Math.floor( j / width );
    }
    ;
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      material = new THREE.ShaderMaterial({
        uniforms: {
          "map": {
            value: this._texture
          },
          "width": {
            value: width
          },
          "height": {
            value: height
          },
          "nearClipping": {
            value: nearClipping
          },
          "farClipping": {
            value: farClipping
          },
          "pointSize": {
            value: 2
          },
          "zOffset": {
            value: 1000
          }
        }
      }, {
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        depthWrite: false,
        transparent: true
      });
      mesh = new THREE.Points(geometry, material);
      return this.scene.add(mesh);
    };

    View.prototype.onRender = function() {
      var dt;
      dt = this.clock.getDelta();
      this._control.update();
    };

    View.prototype.onExit = function() {
      Kinect.DestroyKinect();
    };

    View.prototype._addShadowedLight = function(x, y, z, d, color, intensity) {
      var directLight;
      if (d == null) {
        d = 10000;
      }
      if (color == null) {
        color = 0xffffbb;
      }
      if (intensity == null) {
        intensity = 0.2;
      }
      directLight = new THREE.DirectionalLight(color, intensity);
      directLight.position.set(x, y, z);
      this.scene.add(directLight);
    };

    View.prototype._generateTexture = function() {
      var canvas, i, image, j, ref;
      canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 424;
      this._context = canvas.getContext('2d');
      image = this._context.getImageData(0, 0, 512, 424);
      for (i = j = 0, ref = 512 * 424; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        image.data[i] = Math.random() * 255;
      }
      this._context.putImageData(image, 0, 0);
      return canvas;
    };

    View.prototype._putImageData = function() {
      var image, intensity, ipxl, j, ref;
      image = this._context.getImageData(0, 0, 512, 424);
      for (ipxl = j = 0, ref = 512 * 424 * 4; j < ref; ipxl = j += 4) {
        intensity = this._depthframe[ipxl / 4] % 255;
        image.data[ipxl] = intensity;
        image.data[ipxl + 1] = intensity;
        image.data[ipxl + 2] = intensity;
        image.data[ipxl + 3] = 255;
      }
      this._context.putImageData(image, 0, 0);
    };

    return View;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = View;
  }

}).call(this);

//# sourceMappingURL=kinect-one-pointcloud.js.map
